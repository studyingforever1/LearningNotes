# 计算机网络

## 粘包拆包
### 为什么有拆包/粘包
TCP 传输协议是面向流的，没有数据包界限。客户端向服务端发送数据时，可能将一个完整的报文拆分成多个小报文进行发送，也可能将多个报文合并成一个大的报文进行发送。因此就有了拆包和粘包。

为什么会出现拆包/粘包现象呢？在网络通信的过程中，每次可以发送的数据包大小是受多种因素限制的，如 MTU 传输单元大小、MSS 最大分段大小、滑动窗口等。如果一次传输的网络包数据大小超过传输单元大小，那么我们的数据可能会拆分为多个数据包发送出去。如果每次请求的网络包数据都很小，一共请求了 10000 次，TCP 并不会分别发送 10000 次。因为 TCP 采用的 Nagle 算法对此作出了优化。如果你是一位网络新手，可能对这些概念并不非常清楚。那我们先了解下计算机网络中 MTU、MSS、Nagle 这些基础概念以及它们为什么会造成拆包/粘包问题。
### MTU 最大传输单元和 MSS 最大分段大小

**MTU（Maxitum Transmission Unit）** 是链路层一次最大传输数据的大小。MTU 一般来说大小为 1500 byte。

**MSS（Maximum Segement Size）** 是指 TCP 最大报文段长度，它是传输层一次发送最大数据的大小。

如下图所示，MTU 和 MSS 一般的计算关系为：MSS = MTU - IP 首部 - TCP首部，如果 MSS + TCP 首部 + IP 首部 > MTU，那么数据包将会被拆分为多个发送。这就是拆包现象。（常见的IP首部和TCP首部大小为20字节）

> 通过ip addr命令可以查看到不同网卡的MTU大小，MTU 一般来说大小为 1500 byte。

<img src=".\images\拆包粘包.png" alt="image-20240731102711503" style="zoom:50%;" />

<img src=".\images\粘包拆包.png" style="zoom: 80%;" />

### 滑动窗口

**滑动窗口**是 TCP 传输层用于流量控制的一种有效措施，也被称为**通告窗口**。滑动窗口是数据接收方设置的窗口大小，随后接收方会把窗口大小告诉发送方，以此限制发送方每次发送数据的大小，从而达到流量控制的目的。这样数据发送方不需要每发送一组数据就阻塞等待接收方确认，允许发送方同时发送多个数据分组，每次发送的数据都会被限制在窗口大小内。由此可见，滑动窗口可以大幅度提升网络吞吐量。

那么 TCP 报文是怎么确保数据包按次序到达且不丢数据呢？首先，所有的数据帧都是有编号的，TCP 并不会为每个报文段都回复 ACK 响应，它会对多个报文段回复一次 ACK。假设有三个报文段 A、B、C，发送方先发送了B、C，接收方则必须等待 A 报文段到达，如果一定时间内仍未等到 A 报文段，那么 B、C 也会被丢弃，发送方会发起重试。如果已接收到 A 报文段，那么将会回复发送方一次 ACK 确认。

### Nagle 算法

**Nagle 算法**于 1984 年被福特航空和通信公司定义为 TCP/IP 拥塞控制方法。它主要用于解决频繁发送小数据包而带来的网络拥塞问题。试想如果每次需要发送的数据只有 1 字节，加上 20 个字节 IP Header 和 20 个字节 TCP Header，每次发送的数据包大小为 41 字节，但是只有 1 字节是有效信息，这就造成了非常大的浪费。Nagle 算法可以理解为**批量发送**，也是我们平时编程中经常用到的优化思路，它是在数据未得到确认之前先写入缓冲区，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。

Linux 在默认情况下是开启 Nagle 算法的，在大量小数据包的场景下可以有效地降低网络开销。但如果你的业务场景每次发送的数据都需要获得及时响应，那么 Nagle 算法就不能满足你的需求了，因为 Nagle 算法会有一定的数据延迟。你可以通过 Linux 提供的 TCP_NODELAY 参数禁用 Nagle 算法。Netty 中为了使数据传输延迟最小化，就默认禁用了 Nagle 算法，这一点与 Linux 操作系统的默认行为是相反的。

### 拆包/粘包的解决方案

<img src=".\images\粘包拆包01.png" style="zoom: 80%;" />





在客户端和服务端通信的过程中，服务端一次读到的数据大小是不确定的。如上图所示，拆包/粘包可能会出现以下五种情况：

- 服务端恰巧读到了两个完整的数据包 A 和 B，没有出现拆包/粘包问题；
- 服务端接收到 A 和 B 粘在一起的数据包，服务端需要解析出 A 和 B；
- 服务端收到完整的 A 和 B 的一部分数据包 B-1，服务端需要解析出完整的 A，并等待读取完整的 B 数据包；
- 服务端接收到 A 的一部分数据包 A-1，此时需要等待接收到完整的 A 数据包；
- 数据包 A 较大，服务端需要多次才可以接收完数据包 A。

由于拆包/粘包问题的存在，数据接收方很难界定数据包的边界在哪里，很难识别出一个完整的数据包。所以需要提供一种机制来识别数据包的界限，这也是解决拆包/粘包的唯一方法：**定义应用层的通信协议**。下面我们一起看下主流协议的解决方案。

#### 消息长度固定

每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要空位补齐。

```diff
+----+------+------+---+----+

| AB | CDEF | GHIJ | K | LM |

+----+------+------+---+----+
```

假设我们的固定长度为 4 字节，那么如上所示的 5 条数据一共需要发送 4 个报文：

```diff
+------+------+------+------+

| ABCD | EFGH | IJKL | M000 |

+------+------+------+------+
```

消息定长法使用非常简单，但是缺点也非常明显，无法很好设定固定长度的值，如果长度太大会造成字节浪费，长度太小又会影响消息传输，所以在一般情况下消息定长法不会被采用。

#### 特定分隔符

既然接收方无法区分消息的边界，那么我们可以在每次发送报文的尾部加上**特定分隔符**，接收方就可以根据特殊分隔符进行消息拆分。以下报文根据特定分隔符 \n 按行解析，即可得到 AB、CDEF、GHIJ、K、LM 五条原始报文。

```diff
+-------------------------+

| AB\nCDEF\nGHIJ\nK\nLM\n |

+-------------------------+
```

由于在发送报文时尾部需要添加特定分隔符，所以对于分隔符的选择一定要避免和消息体中字符相同，以免冲突。否则可能出现错误的消息拆分。比较推荐的做法是将消息进行编码，例如 base64 编码，然后可以选择 64 个编码字符之外的字符作为特定分隔符。特定分隔符法在消息协议足够简单的场景下比较高效，例如大名鼎鼎的 Redis 在通信过程中采用的就是换行分隔符。

#### 消息长度 + 消息内容

```diff
消息头     消息体

+--------+----------+

| Length |  Content |

+--------+----------+
```

**消息长度 + 消息内容**是项目开发中最常用的一种协议，如上展示了该协议的基本格式。消息头中存放消息的总长度，例如使用 4 字节的 int 值记录消息的长度，消息体实际的二进制的字节数据。接收方在解析数据时，首先读取消息头的长度字段 Len，然后紧接着读取长度为 Len 的字节数据，该数据即判定为一个完整的数据报文。依然以上述提到的原始字节数据为例，使用该协议进行编码后的结果如下所示：

```diff
+-----+-------+-------+----+-----+

| 2AB | 4CDEF | 4GHIJ | 1K | 2LM |

+-----+-------+-------+----+-----+
```

消息长度 + 消息内容的使用方式非常灵活，且不会存在消息定长法和特定分隔符法的明显缺陷。当然在消息头中不仅只限于存放消息的长度，而且可以自定义其他必要的扩展字段，例如消息版本、算法类型等。





## HTTP

### HTTP状态码

| 状态码                            | 类别                                                | 含义 / 描述                                                  | 常见使用 / 触发场景                                          |
| --------------------------------- | --------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1xx 信息 (Informational)**      | 请求已接收，继续处理                                | —                                                            | 通常在客户端发送分块请求、升级协议、长连接、HTTP/2等场景下使用 |
| 100                               | Continue                                            | 服务器收到请求头，客户端应该继续发送剩余请求主体             | 当客户端分块（chunked）发送较大请求体时，先发 header，服务器回复 100 后再发送 body |
| 101                               | Switching Protocols                                 | 服务器准备按照客户端要求切换协议（如从 HTTP/1.1 切换到 WebSocket/TLS 等） | 浏览器发起 WebSocket 握手、HTTP 升级协议等                   |
| 102                               | Processing (WebDAV)                                 | 表示服务器已收到并且正在处理请求，但处理尚未完成 — 用于防止超时 | WebDAV 多步骤操作、长时间处理请求时                          |
| 103                               | Early Hints                                         | 提前返回部分 header（如 Link, preload），提示客户端可以预加载资源 | 加速页面加载优化（如提前加载 CSS/JS）                        |
| **2xx 成功 (Successful)**         | 请求已成功被服务器接收并处理                        | —                                                            | 常规请求成功、资源创建、部分响应、无内容响应等               |
| 200                               | OK                                                  | 请求成功，响应体包含请求的数据                               | 最常见 — 普通页面 GET、API 返回成功等                        |
| 201                               | Created                                             | 请求成功并创建了新的资源                                     | POST 新建资源，例如用户注册、创建文章等                      |
| 202                               | Accepted                                            | 服务器接受请求，但尚未处理完成（异步/后台执行）              | 异步任务提交、队列任务、延迟处理等                           |
| 203                               | Non-Authoritative Information                       | 服务器成功处理请求，但返回的信息不是来自原始服务器 — 可能是来自代理或网关 | 通过缓存/代理返回内容，或作为中间件返回数据                  |
| 204                               | No Content                                          | 请求成功，但没有返回内容 — 适合删除资源、状态更新等          | DELETE 删除资源、PUT 更新但无需返回内容                      |
| 205                               | Reset Content                                       | 请求成功，但要求客户端重置视图/表单                          | 表单提交后清空表单、客户端重置状态等                         |
| 206                               | Partial Content                                     | 成功响应部分内容 — 通常用于断点续传 / 分块下载               | 浏览器/客户端对大文件分块下载或断点续传                      |
| 207                               | Multi-Status (WebDAV)                               | 对多个子请求分别返回状态 — 响应体通常为 XML／多状态集合      | WebDAV 批量操作、多资源请求                                  |
| 208                               | Already Reported (WebDAV)                           | 避免重复枚举已经在之前的响应中报告过的成员                   | WebDAV 中多次引用同一资源集合时                              |
| 226                               | IM Used                                             | 服务器满足 GET 请求，响应体表示资源实例已由实例管理器处理过  | 内容协商 / 缓存 / delta 编码等较少用场景                     |
| **3xx 重定向 (Redirection)**      | 需要客户端进一步操作（通常是重定向或条件请求）      | —                                                            | 更改 URL、重定向、缓存控制、内容协商等                       |
| 300                               | Multiple Choices                                    | 请求的资源有多个可选表示 — 客户端应选择一个                  | 内容协商 — 例如多种格式/语言可选时                           |
| 301                               | Moved Permanently                                   | 资源已永久移动到新的 URI — 客户端/搜索引擎应更新链接         | 网站域名更换、URL 规范化、SEO 友好重定向                     |
| 302                               | Found (Moved Temporarily)                           | 资源暂时位于另一个 URI — 客户端短期重定向                    | 暂时重定向、登录跳转、过渡期页面等                           |
| 303                               | See Other                                           | 对于 POST 请求，服务器建议客户端以 GET 方法请求另一个 URI    | POST‑/表单提交后跳转到结果页面，避免重复提交                 |
| 304                               | Not Modified                                        | 资源自上次请求后未修改 — 客户端可使用缓存                    | 浏览器缓存验证 (If‑Modified‑Since / ETag / 缓存控制)         |
| 305                               | Use Proxy *(已废弃/不推荐)*                         | 请求的资源需要通过指定代理访问                               | 很少/几乎不用，因安全原因主流浏览器不支持该状态码            |
| 306                               | Switch Proxy *(不再使用)*                           | 曾用于指示后续请求使用特定代理                               | 已废弃，不应使用                                             |
| 307                               | Temporary Redirect                                  | 暂时重定向 — 与 302 类似，但方法 & body 不应改变             | POST / PUT 等请求暂时重定向，如 URL 重写、中间服务重定向等   |
| 308                               | Permanent Redirect                                  | 永久重定向 — 与 301 类似，但请求方法保持不变                 | HTTPS 强制、长期 URL 迁移、API 重构等                        |
| **4xx 客户端错误 (Client Error)** | 请求存在问题 — 客户端修改后可重试                   | —                                                            | 错误请求、权限验证、资源不存在、格式/内容错误、请求过大/不合法等 |
| 400                               | Bad Request                                         | 请求语法错误或无效 — 服务器无法理解请求                      | JSON 格式错误、必需字段缺失、非法参数等                      |
| 401                               | Unauthorized                                        | 需要认证 — 请求未提供有效凭证或凭证无效                      | 登录认证失败、token 过期、未登录访问受限资源                 |
| 402                               | Payment Required                                    | 保留 / 预留 — 计划用于付费相关机制                           | 很少使用，目前主要保留                                       |
| 403                               | Forbidden                                           | 服务器理解请求，但拒绝执行 — 权限不足                        | 权限验证失败，访问被拒绝（如非管理员访问后台）               |
| 404                               | Not Found                                           | 资源不存在                                                   | URL 错误、资源已删除、无效链接等                             |
| 405                               | Method Not Allowed                                  | 请求方法（GET/POST/PUT/DELETE 等）不被允许                   | 对不支持的方法调用 API、REST 接口方法限制等                  |
| 406                               | Not Acceptable                                      | 服务器无法提供满足 `Accept` 请求头要求的响应格式             | 客户端希望某种内容类型/语言，但服务器无此版本                |
| 407                               | Proxy Authentication Required                       | 需要对代理进行身份验证（非目标服务器）                       | 通过代理访问资源但未授权                                     |
| 408                               | Request Timeout                                     | 客户端在服务器等待时间内未发送完整请求                       | 请求太慢、网络延迟、连接超时等                               |
| 409                               | Conflict                                            | 请求与资源当前状态冲突 — 无法完成                            | 版本冲突、资源状态冲突、数据冲突等（例如同时更新同一资源）   |
| 410                               | Gone                                                | 资源曾经存在但已永久删除，而且没有转发地址                   | 删除且不再提供资源 — 比 404 更明确“资源永久不可用”           |
| 411                               | Length Required                                     | 请求需要 `Content-Length` 头，但未提供                       | 某些服务/接口要求指定请求体长度                              |
| 412                               | Precondition Failed                                 | 客户端在请求中设置条件（如 `If-Match`, `If-Unmodified-Since`） — 条件不满足 | 乐观锁、缓存验证、条件请求失败时                             |
| 413                               | Payload Too Large (以前称 Request Entity Too Large) | 请求体太大，服务器拒绝处理                                   | 上传大文件超过服务器限制                                     |
| 414                               | URI Too Long                                        | 请求的 URI（URL）过长                                        | 含大量参数、长查询字符串、不合理 URL 等                      |
| 415                               | Unsupported Media Type                              | 请求中包含的媒体类型（Content-Type）不被支持                 | 客户端发送不受支持的 MIME 类型                               |
| 416                               | Range Not Satisfiable                               | 请求了无效范围 — 例如分片下载，但指定的范围无效              | 客户端请求文件分片，但范围超出文件大小                       |
| 417                               | Expectation Failed                                  | 请求头 `Expect` 的值服务器无法满足                           | 客户端使用 `Expect` 而服务器不支持                           |
| 418                               | I’m a teapot                                        | 《愚人节愚人协议》(RFC 2324) — 作为彩蛋/趣味状态码           | 几乎不用于实际 HTTP，只是 RFC 保留 / 玩笑                    |
| 421                               | Misdirected Request                                 | 请求被发送到不适合响应的服务器                               | 多域名、代理、虚拟主机配置问题                               |
| 422                               | Unprocessable Entity (WebDAV)                       | 请求格式正确，但语义错误 — 无法处理                          | RESTful API 参数校验失败、WebDAV 操作失败等                  |
| 423                               | Locked (WebDAV)                                     | 资源被锁定，无法访问或修改                                   | WebDAV 文件锁、资源并发访问锁定                              |
| 424                               | Failed Dependency (WebDAV)                          | 当前请求依赖的操作失败 — 导致此请求失败                      | WebDAV 批量操作中某一步失败                                  |
| 425                               | Too Early                                           | 服务器不愿意处理可能被重放（replay）的请求                   | 防重放攻击 / 提高安全限制时                                  |
| 426                               | Upgrade Required                                    | 客户端应切换为另一个协议（如 TLS）                           | 强制 HTTPS / HTTP 升级                                       |
| 428                               | Precondition Required                               | 服务器要求请求必须包含条件 — 防止“丢失更新”                  | 乐观锁 / 资源更新必须带条件头                                |
| 429                               | Too Many Requests                                   | 客户端发送太多请求 — 达到速率限制                            | 防止 DDOS、限制 API 调用频率                                 |
| 431                               | Request Header Fields Too Large                     | 请求头字段太大，服务器拒绝                                   | 请求头过大（cookie 太多 / header 太长）                      |
| 451                               | Unavailable For Legal Reasons                       | 因法律原因拒绝访问                                           | 法律/监管 / 内容审查 / 合规要求                              |
| **5xx 服务器错误 (Server Error)** | 服务器在处理合法请求时发生错误                      | —                                                            | 服务端异常、资源不足、代理/网关错误、版本不支持等            |
| 500                               | Internal Server Error                               | 服务器遇到意外情况，无法完成请求                             | 未捕获异常、程序错误、运行时错误等                           |
| 501                               | Not Implemented                                     | 服务器不支持请求的方法或功能                                 | 方法不实现（例如服务器不支持 PUT/DELETE）、功能缺失          |
| 502                               | Bad Gateway                                         | 作为网关或代理时，从上游服务器收到无效响应                   | 代理/网关失败、上游服务崩溃 / 响应错误                       |
| 503                               | Service Unavailable                                 | 服务器暂时过载或停机维护，无法处理请求                       | 服务维护、过载、资源耗尽、流量高峰等                         |
| 504                               | Gateway Timeout                                     | 作为网关/代理时，上游服务器响应超时                          | 后端服务慢 / 不响应、网络拥堵、超时设置                      |
| 505                               | HTTP Version Not Supported                          | 服务器不支持请求所用的 HTTP 版本                             | 客户端使用过时或不支持的 HTTP 协议                           |
| 506                               | Variant Also Negotiates                             | 服务器配置错误 — 内容协商循环                                | 内容协商 / 资源版本冲突 / 配置错误                           |
| 507                               | Insufficient Storage (WebDAV)                       | 服务器无法存储完成请求所需内容                               | WebDAV 上传失败、磁盘/存储空间不足等                         |
| 508                               | Loop Detected (WebDAV)                              | 服务器在处理请求时检测到无限循环                             | WebDAV 递归引用 / 配置错误 / 资源引用循环                    |
| 510                               | Not Extended                                        | 请求需要进一步扩展才能被满足                                 | 请求缺少必要的扩展协议 / 扩展参数                            |
| 511                               | Network Authentication Required                     | 客户端需要进行网络级认证（如 captive‑portal）                | 公共 WiFi 登录页、网络认证页面、代理网络凭证等               |







### Content-Type

`Content-Type` 是 HTTP 头（Header）的一部分，用来告诉客户端或服务器发送的 **实体内容的类型**，也就是数据格式。

```text
Content-Type: type/subtype; 参数
```

- `type`：主类型（如 `text`、`image`、`application`）
- `subtype`：子类型（如 `html`、`json`、`png`）
- 参数：可选，例如 `charset=UTF-8` 用来指定字符编码

| 主类型        | 含义                                                         | 示例子类型（部分）                                           |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `*`           | 通配符类型，表示匹配任意类型或子类型，常用于 Accept 头       | `*/*`                                                        |
| `application` | 应用程序数据，不是直接可显示的文本或图像，常用于 JSON、XML、PDF、二进制数据 | `json`, `xml`, `pdf`, `octet-stream`, `x-www-form-urlencoded`, `x-protobuf` |
| `image`       | 图像数据类型，可直接显示                                     | `gif`, `jpeg`, `png`                                         |
| `multipart`   | 消息由多个部分组成，每部分可有自己的 Content-Type，常用于文件上传或复杂表单 | `form-data`, `mixed`, `related`                              |
| `text`        | 纯文本内容，可直接显示或渲染，默认编码通常为 US-ASCII 或 UTF-8 | `plain`, `html`, `markdown`, `xml`, `event-stream`           |



#### 常见Content-Type

| Content-Type                             | 备注                                 |
| ---------------------------------------- | ------------------------------------ |
| `*/*`                                    | 通配符类型，表示接受所有类型         |
| `application/atom+xml`                   | Atom feed                            |
| `application/cbor`                       | CBOR（二进制 JSON）                  |
| `application/x-www-form-urlencoded`      | 表单 URL 编码数据                    |
| `application/graphql+json`               | GraphQL 请求（已废弃，推荐用下一个） |
| `application/graphql-response+json`      | GraphQL 响应                         |
| `application/json`                       | JSON 数据                            |
| `application/json;charset=UTF-8`         | JSON 数据（UTF-8，已废弃）           |
| `application/octet-stream`               | 二进制流数据                         |
| `application/pdf`                        | PDF 文件                             |
| `application/problem+json`               | HTTP API 错误信息（JSON）            |
| `application/problem+json;charset=UTF-8` | HTTP API 错误信息（已废弃）          |
| `application/problem+xml`                | HTTP API 错误信息（XML）             |
| `application/x-protobuf`                 | Protocol Buffers 数据                |
| `application/rss+xml`                    | RSS feed                             |
| `application/x-ndjson`                   | NDJSON（newline-delimited JSON）     |
| `application/stream+json`                | 流式 JSON（已废弃，推荐 NDJSON）     |
| `application/xhtml+xml`                  | XHTML 文档                           |
| `application/xml`                        | XML 文档                             |
| `image/gif`                              | GIF 图片                             |
| `image/jpeg`                             | JPEG 图片                            |
| `image/png`                              | PNG 图片                             |
| `multipart/form-data`                    | 表单数据（文件上传）                 |
| `multipart/mixed`                        | 混合多部分内容                       |
| `multipart/related`                      | 相关多部分内容                       |
| `text/event-stream`                      | SSE（Server-Sent Events）            |
| `text/html`                              | HTML 页面                            |
| `text/markdown`                          | Markdown 文档                        |
| `text/plain`                             | 纯文本                               |
| `text/xml`                               | XML 文档                             |

#### Content-Type示例

##### application/x-www-form-urlencoded

```http
POST /login HTTP/1.1
Content-Type: application/x-www-form-urlencoded

username=alice&password=123456
```

##### application/json

```http
POST /api/user HTTP/1.1
Content-Type: application/json

{
  "name": "Alice",
  "age": 30
}
```

##### application/octet-stream

```http
POST /api/upload HTTP/1.1
Content-Type: application/octet-stream

<binary data>
```

##### multipart/form-data

```http
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

Hello World
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

##### multipart/mixed

```HTTP
POST /api/mixed HTTP/1.1
Content-Type: multipart/mixed; boundary=boundary123

--boundary123
Content-Type: text/plain

Hello
--boundary123
Content-Type: application/json

{"foo":"bar"}
--boundary123--

```

##### text/event-stream

```HTTP
GET /events HTTP/1.1
Accept: text/event-stream

data: {"id":1,"message":"Hello"}
data: {"id":2,"message":"World"}

```

##### text/plain

```HTTP
POST /api/text HTTP/1.1
Content-Type: text/plain

Hello World

```





http中的HttpResponseStatus可以为100，请求头的expect:100-continue也代表100的意思

### TCP 层面的 Keep-Alive

TCP 层面的 `keep-alive` 是为了检测并关闭已经失效的连接。它通过周期性地发送小数据包来确认连接的另一端仍然活跃。如果一段时间内没有接收到任何数据，TCP 将开始发送 `keep-alive` 探测包。如果在连续几次尝试之后仍然没有响应，则认为连接已失效，并将其关闭。

TCP 层面的 `keep-alive` 主要有以下几个特点：

- **目的**：检测连接是否仍然可用。
- **机制**：发送小数据包来检查连接状态。
- **触发条件**：在一段时间内没有数据交换时启动。
- **实现**：由操作系统实现，通常可通过系统配置进行调整。

```bash
# 查看当前的 keep-alive 参数
cat /proc/sys/net/ipv4/tcp_keepalive_time #默认为 7200 秒（2小时），表示在开始发送keep-alive探测前的空闲时间
cat /proc/sys/net/ipv4/tcp_keepalive_intvl # 默认为 75 秒，表示发送两次keep-alive探测之间的间隔。
cat /proc/sys/net/ipv4/tcp_keepalive_probes # 默认为 9 次，表示连续发送探测包的次数。

# 修改 keep-alive 参数
sysctl -w net.ipv4.tcp_keepalive_time=<value_in_seconds>
sysctl -w net.ipv4.tcp_keepalive_intvl=<value_in_seconds>
sysctl -w net.ipv4.tcp_keepalive_probes=<number_of_probes>
```

### HTTP 层面的 Keep-Alive

HTTP 协议中的 `keep-alive` 机制则是为了提高性能而设计的，尤其是在 HTTP/1.x 版本中。默认情况下，每个 HTTP 请求都会打开一个新的 TCP 连接，请求完成后连接会被关闭。但启用 `keep-alive` 后，同一个 TCP 连接可以被重复使用，以发送多个 HTTP 请求。

HTTP 层面的 `keep-alive` 主要有以下几个特点：

- **目的**：减少连接建立和关闭的开销，提高性能。
- **机制**：通过在 HTTP 头部添加 `Connection: keep-alive` 字段来指示客户端和服务端保持连接。
- **触发条件**：每当客户端发出请求时，只要 `keep-alive` 被启用，连接就会被保留。
- **实现**：由 HTTP 客户端和服务器通过 HTTP 头部进行协商。

**总结**

- **TCP 层面的 Keep-Alive** 是为了检测连接的状态，防止空闲连接被意外关闭。
- **HTTP 层面的 Keep-Alive** 是为了提高效率，允许重用同一个 TCP 连接发送多个 HTTP 请求。





### HTTP缓存

HTTP 缓存的主要目的是 **减少网络请求，提高性能**，避免重复下载相同资源。浏览器、CDN 或代理服务器都可以做缓存。

缓存的核心原理是：

1. 客户端请求资源（如 HTML、CSS、JS、图片）。
2. 服务器返回资源，同时在响应头中告诉客户端 **是否可以缓存**、**缓存多久**。
3. 当客户端再次请求同一资源时，会根据缓存策略决定：
   - **直接使用缓存**
   - **向服务器验证缓存是否有效**
   - **重新下载资源**

**请求流程**

- 浏览器第一次请求

  ```http
  GET /style.css HTTP/1.1
  Host: example.com
  ```

- 服务器响应

  ```http
  HTTP/1.1 200 OK
  Last-Modified: Tue, 04 Nov 2025 12:00:00 GMT
  ETag: "abc123"
  Cache-Control: no-cache
  ```

- 第二次请求（协商缓存）

  ```http
  GET /style.css HTTP/1.1
  Host: example.com
  If-Modified-Since: Tue, 04 Nov 2025 12:00:00 GMT
  If-None-Match: "abc123"
  ```

- 服务器判断缓存是否有效：

  - 如果资源未改变，返回：

    ```http
    HTTP/1.1 304 Not Modified
    ```

  - 如果资源改变，返回：

    ```http
    HTTP/1.1 200 OK
    新资源
    ```

**HTTP**头

| 头部              | 类型      | 作用                             | 典型用途                                            | 注意事项                                     |
| ----------------- | --------- | -------------------------------- | --------------------------------------------------- | -------------------------------------------- |
| **Cache-Control** | 响应/请求 | 控制缓存策略，精细化管理缓存行为 | 浏览器缓存、CDN缓存、代理缓存                       | HTTP/1.1 推荐使用，优先级高于 Expires        |
| **Expires**       | 响应      | 资源绝对过期时间（GMT）          | 静态资源强缓存                                      | HTTP/1.0 使用，HTTP/1.1 推荐用 Cache-Control |
| **ETag**          | 响应      | 资源唯一标识（通常是文件 hash）  | 协商缓存（If-Match / If-None-Match）                | 与 If-Match / If-None-Match 配合使用         |
| **Last-Modified** | 响应      | 资源最后修改时间                 | 协商缓存（If-Modified-Since / If-Unmodified-Since） | 精度到秒，配合时间戳条件请求头使用           |

**Cache-Control 常用指令**

| 指令              | 作用                               | 适用场景               |
| ----------------- | ---------------------------------- | ---------------------- |
| `max-age=<秒>`    | 资源在多少秒内是新鲜的             | 强缓存，静态资源       |
| `no-cache`        | 允许缓存，但每次请求需向服务器验证 | 动态资源，保证最新内容 |
| `no-store`        | 资源不缓存                         | 敏感数据，安全要求高   |
| `private`         | 仅浏览器缓存                       | 用户特定资源           |
| `public`          | 所有缓存（浏览器+代理）都可缓存    | 静态资源，CDN          |
| `must-revalidate` | 缓存过期后必须向服务器验证         | 动态内容控制           |

#### If-Match

**作用：**

- 客户端告诉服务器：**“只在资源的 ETag 与我提供的一致时才执行操作（通常是 PUT 或 DELETE）”**。
- 如果不一致 → 服务器返回 **412 Precondition Failed**。

**典型用途：**

- **乐观锁（optimistic locking）**
  确保客户端修改的是最新版本，防止覆盖其他人更新。

**示例：**

```http
PUT /resource/123 HTTP/1.1
If-Match: "abc123"
Content-Type: application/json

{ "name": "new name" }
```

- 当前资源的 ETag 是 `"abc123"` → 更新成功，返回 200 OK
- 当前资源的 ETag 不是 `"abc123"` → 返回 412 Precondition Failed

> 关键：If-Match **用于更新或删除操作**，保证数据一致性。

#### If-None-Match

**作用：**

- 客户端告诉服务器：**“如果资源的 ETag 和我提供的相同，就不要返回内容”**。
- 如果 ETag 相同 → 返回 **304 Not Modified**
- 如果不同 → 返回 **200 OK** 和资源内容

**典型用途：**

- **协商缓存**（浏览器缓存验证）
- **避免重复提交请求**

**示例：**

```http
GET /style.css HTTP/1.1
If-None-Match: "abc123"
```

- 如果服务器资源 ETag 仍为 `"abc123"` → 304 Not Modified → 浏览器直接使用缓存
- 如果服务器资源 ETag 改变 → 200 OK + 新资源

> 关键：If-None-Match **常用于 GET 或 HEAD 请求进行缓存验证**，和 412 不直接相关。

------

#### If-Modified-Since

**作用：**

- 客户端告诉服务器：**“只在资源自某个时间点后被修改过时才返回”**
- 如果资源自指定时间没有修改 → 304 Not Modified
- 如果修改过 → 返回 200 OK

**典型用途：**

- **协商缓存**（浏览器缓存验证）

**示例：**

```http
GET /style.css HTTP/1.1
If-Modified-Since: Tue, 04 Nov 2025 12:00:00 GMT
```

- 资源自 2025-11-04 12:00 后没有改 → 304 Not Modified
- 资源修改过 → 200 OK + 新内容

> 关键：基于 **时间戳** 的缓存验证。

------

#### If-Unmodified-Since

**作用：**

- 客户端告诉服务器：**“只在资源自某个时间后没有被修改时才执行操作（通常是 PUT/DELETE）”**
- 如果资源自指定时间被修改过 → 返回 **412 Precondition Failed**
- 如果未修改 → 执行操作

**典型用途：**

- 数据一致性校验，防止覆盖已更新的资源

**示例：**

```http
DELETE /resource/123 HTTP/1.1
If-Unmodified-Since: Tue, 04 Nov 2025 12:00:00 GMT
```

- 如果资源自指定时间未修改 → 执行删除
- 如果资源修改过 → 412 Precondition Failed

> 关键：基于 **时间戳** 的乐观锁。

| 请求头                | 作用                                 | 对应响应        | 典型使用场景        | 说明                                             |
| --------------------- | ------------------------------------ | --------------- | ------------------- | ------------------------------------------------ |
| `If-Modified-Since`   | 只有资源自指定时间后被修改才返回     | `Last-Modified` | GET / HEAD 协商缓存 | 基于时间戳的缓存验证                             |
| `If-Unmodified-Since` | 只有资源自指定时间未被修改才执行操作 | `Last-Modified` | PUT / DELETE 乐观锁 | 基于时间戳的数据一致性                           |
| `If-Match`            | 只有资源 ETag 匹配才执行操作         | `ETag`          | PUT / DELETE 乐观锁 | 保证更新的是最新资源                             |
| `If-None-Match`       | 只有资源 ETag 不匹配才返回内容       | `ETag`          | GET / HEAD 协商缓存 | 避免重复请求；如果匹配 → 304 Not Modified        |
| `Pragma`              | 兼容 HTTP/1.0 的缓存控制             | -               | no-cache            | 老旧浏览器用，作用类似 `Cache-Control: no-cache` |







### 重定向与转发

#### 重定向

HTTP 重定向是服务器告诉浏览器或客户端“请求的资源已经移动到另一个 URL”，客户端应该去新的 URL 获取资源的机制。

1. 用户在浏览器中访问 URL A。

2. 服务器判断该请求需要重定向到 URL B。

3. 服务器返回一个 HTTP 响应，通常包含：

   状态码（3xx 系列）

   `Location` 响应头，指明新的 URL

4. 浏览器收到响应后，自动发起对新 URL 的请求。

5. 浏览器访问 URL B 并显示内容给用户。

#### 转发

**请求在服务器内部从一个资源传递到另一个资源处理**，浏览器并不知道发生了转发

- 浏览器请求 URL A
- 服务器决定让内部的 URL B 来处理请求
- 服务器把请求交给 URL B，返回的响应直接给浏览器
- **浏览器地址栏仍然是 URL A**（和重定向不同）

| 特性             | 转发（Forward）                  | 重定向（Redirect）                     |
| ---------------- | -------------------------------- | -------------------------------------- |
| 发生位置         | 服务器内部                       | 客户端发起                             |
| URL 是否改变     | 不改变                           | 改变                                   |
| 是否重新发请求   | 否                               | 是，浏览器重新发送请求                 |
| 可访问资源       | 服务器内部路径                   | 可访问任何 URL（内外部）               |
| 性能             | 高（服务器内部跳转，无额外网络） | 较低（浏览器新请求，增加一次网络往返） |
| 浏览器地址栏显示 | 不变                             | 改变                                   |
| 数据传递方式     | Request Attribute                | URL 参数或 Session                     |









