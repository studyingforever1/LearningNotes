# 认证系统

## Oauth2.1

https://datatracker.ietf.org/doc/draft-ietf-oauth-v2-1/

OAuth 2.1 是一个授权框架（Authorization Framework），允许第三方应用在**不获取用户凭证**（用户名/密码）的情况下，**受限访问资源服务器上的受保护资源**。

| 角色（英文）         | 中文名称   | 缩写 | 说明                                                         |
| -------------------- | ---------- | ---- | ------------------------------------------------------------ |
| Resource Owner       | 资源所有者 | RO   | 能够授予对受保护资源访问权限的实体。当该实体为个人时，称为终端用户（End User）。 |
| Resource Server      | 资源服务器 | RS   | 托管受保护资源的服务器，使用访问令牌接收并响应受保护资源请求，通常以 API 形式提供服务。 |
| Client               | 客户端     | —    | 在资源所有者授权下，代表资源所有者访问受保护资源的应用程序，不限定具体实现形态。 |
| Authorization Server | 授权服务器 | AS   | 在成功认证资源所有者并获得授权后，向客户端签发访问令牌的服务器。 |

在工程实践中，Authorization Server 和 Resource Server 可以是同一系统，但在协议语义上是分离的。

### 工作流程

<img src="./images/image-20251218111540735.png" alt="image-20251218111540735" style="zoom: 50%;" />

图 1 所示的 OAuth 2.1 抽象流程描述了四种角色之间的交互，包含以下步骤：

1. **客户端向资源所有者请求授权**。
    授权请求可以直接向资源所有者发起（如图中所示），但更推荐通过授权服务器作为中介，以间接方式进行。
2. **客户端获得授权许可（authorization grant）**。
    授权许可是一种表示资源所有者授权的凭据，其形式为本规范中定义的某一种授权许可类型，或扩展的授权许可类型。具体采用哪种授权许可类型，取决于客户端请求授权所使用的方法以及授权服务器所支持的类型。
3. **客户端向授权服务器请求访问令牌（access token）**，
    方式是向授权服务器进行身份认证，并出示所获得的授权许可。
4. **授权服务器对客户端进行认证并验证授权许可**，
    如果授权许可有效，则向客户端签发访问令牌。
5. **客户端向资源服务器请求受保护资源**，
    并通过出示访问令牌来完成身份验证。
6. **资源服务器验证访问令牌**，
    若令牌有效，则处理并返回相应的受保护资源请求结果。

### 授权模式

为了请求访问令牌，客户端需要先从资源所有者处获得授权。本规范定义了以下几种授权许可（authorization grant）类型：

- **授权码（authorization code）**
- **客户端凭证（client credentials）**
- **刷新令牌（refresh token）**

#### 授权码模式

<img src="./images/image-20251218113300482.png" alt="image-20251218113300482" style="zoom: 50%;" />

<img src="./images/f728d327bb00435e8f3b809fadb5f11a.png" style="zoom: 80%;" />

1. **客户端发起流程**，将资源所有者的用户代理（user agent）引导至授权端点（authorization endpoint）。
    客户端在请求中包含其客户端标识符（client identifier）、代码挑战（code challenge，基于生成的代码校验器 code verifier 派生）、可选的请求作用域（scope）、可选的本地状态值（state），以及一个重定向 URI。授权服务器在访问被授予（或被拒绝）后，将通过该重定向 URI 把用户代理送回客户端。
2. **授权服务器通过用户代理对资源所有者进行身份认证**，并确认资源所有者是否同意或拒绝客户端的访问请求。
3. **假设资源所有者同意授权**，授权服务器使用之前提供的重定向 URI（在请求中或在客户端注册期间指定）将用户代理重定向回客户端。
    该重定向 URI 中包含一个授权码（authorization code）以及客户端先前提供的任何本地状态值（state）。
4. **客户端向授权服务器的令牌端点（token endpoint）请求访问令牌**，
    请求中包含在前一步获得的授权码，并同时提供其代码校验器（code verifier）。在发起请求时，如果客户端具备条件，则需向授权服务器进行客户端身份认证。客户端还必须包含用于获取授权码的重定向 URI，以供校验。
5. **授权服务器在可能的情况下对客户端进行身份认证**，并验证授权码、验证代码校验器，同时确保所接收到的重定向 URI 与步骤 (3) 中用于重定向客户端的 URI 一致。
    若所有校验均通过，授权服务器将返回访问令牌，并可选地返回刷新令牌。



##### PKCE（Proof Key for Code Exchange）

OAuth 2.0 的授权码模式（Authorization Code Grant）是一种常见的授权方式，适用于服务器端应用程序。为了增强其安全性，特别是在移动应用和单页应用（SPA）中，OAuth 2.0 引入了 PKCE（Proof Key for Code Exchange，代码交换证明密钥）扩展。

PKCE 通过引入 `code_challenge` 和 `code_verifier` 两个参数来防止授权码拦截攻击。

| 名称                    | 含义                         | RFC 属性                        |
| ----------------------- | ---------------------------- | ------------------------------- |
| `code_verifier`         | 高熵随机字符串（43~128字符） | 由客户端生成                    |
| `code_challenge`        | `code_verifier` 的派生值     | 通过 `S256` 或 `plain` 生成     |
| `code_challenge_method` | 指定派生方法                 | `S256`（推荐）、`plain`（兼容） |

1. **code_verifier**：首先，客户端生成一个高熵的随机字符串，称为 `code_verifier`。这个字符串通常长度在43到128个字符之间，可以包含字母、数字、连字符、下划线、点和波浪线。
2. code_challenge：接下来，客户端对`code_verifier`进行处理，生成`code_challenge`。有两种方法可以生成`code_challenge`：
   - **plain**：直接使用 `code_verifier` 作为 `code_challenge`。
   - **S256**：对 `code_verifier` 进行 SHA-256 哈希运算，然后对结果进行 Base64 URL 安全编码，生成 `code_challenge`。



##### Authorization Request

| 参数                  | 意义                                                         |
| --------------------- | ------------------------------------------------------------ |
| response_type         | code，表示客户端希望使用 **授权码流程**。                    |
| client_id             | 客户端标识符                                                 |
| code_challenge        | 由 code verifier 派生出的 code challenge。                   |
| code_challenge_method | 如果未提供则默认为 `plain`。code verifier 的转换方法为 `S256` 或 `plain`。 |
| redirect_uri          | 重定向 URI                                                   |
| scope                 | 访问请求的权限范围                                           |
| state                 | 授权服务器在重定向用户代理回客户端时会包含该值。             |

```http
GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
    &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
    &code_challenge=6fdkQaPm51l13DSukcAH3Mdx7_ntecHYd1vi3n0hMZY
    &code_challenge_method=S256 HTTP/1.1
Host: server.example.com
```

##### Authorization Response

| 响应值 | 意义                                                         |
| ------ | ------------------------------------------------------------ |
| code   | 授权服务器生成授权码                                         |
| state  | 如果客户端在授权请求中提供了 state 参数，则返回与客户端收到的值完全相同。 |
| iss    | 授权服务器的标识符                                           |

授权服务器通过 HTTP 重定向返回给用户代理的响应：

```http
HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA
       &state=xyz&iss=https%3A%2F%2Fauthorization-server.example.com
```



#### 令牌获取

##### Token Request

| 参数          | 意义                                                         |
| ------------- | ------------------------------------------------------------ |
| grant_type    | 标识客户端此次令牌请求使用的授权类型`authorization_code`（授权码）`refresh_token`（刷新令牌）`client_credentials`（客户端凭据） |
| code          | 客户端从授权服务器收到的授权码。                             |
| code_verifier | 原始的 code verifier 字符串。                                |
| client_id     | 客户端标识符                                                 |

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code
&code=SplxlOBeZQQYbYS6WxSbIA
&code_verifier=3641a2d12d66101249cdf7a79c000c1f8c05d2aafcf14bf146497bed

```

##### Token Response

如果 **访问令牌请求有效且已授权**，授权服务器会颁发一个 **访问令牌（access token）**，并可选地颁发 **刷新令牌（refresh token）**。

| 响应          | 意义                                                         |
| ------------- | ------------------------------------------------------------ |
| access_token  | 授权服务器颁发的访问令牌。                                   |
| token_type    | 访问令牌的类型                                               |
| expires_in    | 表示访问令牌的有效期（秒）。例如值 `3600` 表示访问令牌从响应生成时起一小时后过期。 |
| scope         | 表示访问令牌的权限范围                                       |
| refresh_token | 刷新令牌，可用于基于相应令牌请求的授权类型获取新的访问令牌。 |
| id_token      | ID令牌                                                       |

```http
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store

  {
   "access_token": "SlAV32hkKG",
   "token_type": "Bearer",
   "refresh_token": "8xLOxBtZp8",
   "expires_in": 3600,
   "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc
     yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5
     NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ
     fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz
     AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q
     Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ
     NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd
     QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS
     K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4
     XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg"
  }
```

##### Bearer Tokens

Bearer Token 是一种安全凭证，**任何持有者都可以使用它访问受保护资源**。而不需要证明持有特定的加密密钥材料

```header
Authorization: Bearer <access_token>
```

##### Sender-Constrained Access Tokens

**发送者约束访问令牌**将访问令牌的使用绑定到特定发送者。发送者必须证明其知晓某个密钥或秘密，才能被接收方（例如资源服务器）接受该访问令牌







##### ID Token

OpenID Connect 对 OAuth 2.0 的主要扩展，是通过 **ID Token** 数据结构来实现终端用户（End-User）身份认证的。

**ID Token** 是一种安全令牌，包含以下信息：

- 由授权服务器（Authorization Server）对终端用户进行身份认证的声明（Claims）
- 可能还包含客户端请求的其他声明

ID Token 通常表示为 **JSON Web Token（JWT）**

| Claim 名称    | 是否必填      | 类型               | 描述                                                         | 示例                             |
| ------------- | ------------- | ------------------ | ------------------------------------------------------------ | -------------------------------- |
| **iss**       | 必填          | 字符串 (URL)       | 发行者标识符（Issuer Identifier），包含 scheme、host，可选 port/path | `https://server.example.com`     |
| **sub**       | 必填          | 字符串             | 主题标识符（Subject Identifier），在发行者范围内唯一         | `24400320`                       |
| **aud**       | 必填          | 字符串或字符串数组 | 受众（Audience），必须包含客户端 `client_id`                 | `"s6BhdRkqt3"`                   |
| **exp**       | 必填          | 数字 (UTC 秒)      | 过期时间（Expiration Time），之后 ID Token 不被接受          | `1311281970`                     |
| **iat**       | 必填          | 数字 (UTC 秒)      | 签发时间（Issued At）                                        | `1311280970`                     |
| **auth_time** | 条件必填/可选 | 数字 (UTC 秒)      | 用户认证时间，当请求 `max_age` 或作为必填声明时必填          | `1311280969`                     |
| **nonce**     | 可选但推荐    | 字符串             | 防重放攻击，将客户端会话与 ID Token 关联                     | `"n-0S6_WzA2Mj"`                 |
| **acr**       | 可选          | 字符串             | 认证上下文类引用，表示认证等级                               | `"urn:mace:incommon:iap:silver"` |
| **amr**       | 可选          | 字符串数组         | 认证方法引用，例如使用的认证方式 `password`、`otp`           | `["pwd","otp"]`                  |
| **azp**       | 可选          | 字符串             | 授权方（Authorized Party），ID Token 颁发对象                | `"s6BhdRkqt3"`                   |

```jwt
{
 "iss": "https://server.example.com",
 "sub": "24400320",
 "aud": "s6BhdRkqt3",
 "nonce": "n-0S6_WzA2Mj",
 "exp": 1311281970,
 "iat": 1311280970,
 "auth_time": 1311280969,
 "acr": "urn:mace:incommon:iap:silver"
}
```



#### 客户端模式

客户端可以仅使用其 **客户端凭证**（Client Credentials）请求访问令牌。

<img src="./images/image-20251218143914336.png" alt="image-20251218143914336" style="zoom:50%;" />

1. **客户端认证并请求访问令牌**

   客户端使用其凭证向 **令牌端点（Token Endpoint）** 发送请求

   请求中包含 `grant_type=client_credentials` 以及客户端凭证（如 client_id/client_secret 或其他认证方式）

2. **授权服务器验证并颁发令牌**

   授权服务器验证客户端凭证

   如果凭证有效，则颁发访问令牌（Access Token）

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials

```

#### 令牌刷新模式

刷新令牌是由 **授权服务器（Authorization Server）** 颁发给客户端的一种凭证，可用于基于现有授权（grant）获取新的访问令牌（Access Token）。

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
```





#### 设备码模式

<img src="./images/device-login.CySyk91u_Qyzyx.webp" style="zoom:50%;" />

```http
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code
&device_code=GmRhmhcxhwEzkoEqiMEg_DnyEysNkuNhszIySk9eS
&client_id=C409020731
```

> `urn:ietf:params:oauth:grant-type:device_code` 的含义这个值并不是随意定义的，而是 **由 IETF 在 RFC 8628 中正式定义并注册的**。
>
> “IETF 定义的 OAuth 授权类型 —— 设备授权（Device Code）”
>
> | 部分          | 含义                                  |
> | ------------- | ------------------------------------- |
> | `urn`         | 统一资源名称（Uniform Resource Name） |
> | `ietf`        | IETF（标准制定组织）                  |
> | `params`      | 参数命名空间                          |
> | `oauth`       | OAuth 协议族                          |
> | `grant-type`  | 授权类型分类                          |
> | `device_code` | 设备授权流程的具体类型                |





### 认证方式

#### HTTP Basic 认证

- **方式**：在 HTTP 请求头中使用 `Authorization: Basic <credentials>`
  - `<credentials>` = `Base64(client_id:client_secret)`
- **优点**：安全、标准化、易实现
- **适用场景**：保密客户端（Confidential Client）

```http
POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```

#### 密钥 POST 认证

- **方式**：在请求体中提交 `client_id` 和 `client_secret`
- **优点**：可以在无法使用 HTTP 头的环境下使用（例如部分浏览器或脚本）
- **缺点**：需要确保请求体经过 TLS，否则凭证易被窃取

```http
POST /token HTTP/1.1
Host: server.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&client_id=s6BhdRkqt3&client_secret=shhh-its-a-secret
```



## JWT

**JWT（JSON Web Token）**是一种基于 JSON 的开放标准（RFC 7519），用于在各方之间安全地传输信息。它主要用于：

- 身份认证（Authentication）
- 授权（Authorization）
- 信息交换（Information Exchange）

JWT 的核心思想是：服务器生成一个经过签名的 token，客户端保存该 token 并在每次请求时发送给服务器，服务器通过验证 token 确认请求身份或权限。

> JWT 只是一种承载声明的格式，不决定是加密还是签名。
>
> 有两种 JWT：
>
> - **JWS**（签名 JWT，JSON Web Signature）
> - **JWE**（加密 JWT，JSON Web Encryption）

### JWT 结构

JWT 由三部分组成，每部分之间用点 `.` 分隔：

```java
xxxxx.yyyyy.zzzzz
```

#### Header（头部）

Header 通常由两部分组成：

- `typ`（Type）：令牌类型，也就是 JWT。
- `alg`（Algorithm）：签名算法，比如 HS256。

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

JSON 形式的 Header 被转换成 Base64 编码，成为 JWT 的第一部分。



#### Payload（负载）

Payload 也是 JSON 格式数据，其中包含了 Claims(声明，包含 JWT 的相关信息)。

Claims 分为三种类型：

- **Registered Claims（注册声明）**：预定义的一些声明，建议使用，但不是强制性的。
- **Public Claims（公有声明）**：JWT 签发方可以自定义的声明，但是为了避免冲突，应该在 [IANA JSON Web Token Registry](https://www.iana.org/assignments/jwt/jwt.xhtml) 中定义它们。
- **Private Claims（私有声明）**：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。

下面是一些常见的注册声明：

- `iss`（issuer）：JWT 签发方。
- `iat`（issued at time）：JWT 签发时间。
- `sub`（subject）：JWT 主题。
- `aud`（audience）：JWT 接收方。
- `exp`（expiration time）：JWT 的过期时间。
- `nbf`（not before time）：JWT 生效时间，早于该定义的时间的 JWT 不能被接受处理。
- `jti`（JWT ID）：JWT 唯一标识。

```json
{
  "uid": "ff1212f5-d8d1-4496-bf41-d2dda73de19a",
  "sub": "1234567890",
  "name": "John Doe",
  "exp": 15323232,
  "iat": 1516239022,
  "scope": ["admin", "user"]
}
```

JSON 形式的 Payload 被转换成 Base64 编码，成为 JWT 的第二部分。



#### Signature（签名）

Signature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。

这个签名的生成需要用到：

- Header + Payload。
- 存放在服务端的密钥。
- 签名算法。

```text
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

### JWS

JWS（JSON Web Signature） 是对 JWT **签名**的标准，用来保证数据**完整性和可信性**。

| 算法  | 类型          | 特点                    |
| ----- | ------------- | ----------------------- |
| HS256 | HMAC（对称）  | 实现简单，需共享 secret |
| RS256 | RSA（非对称） | 私钥签名，公钥验证      |
| ES256 | ECDSA         | 密钥更小，性能更好      |



### JWE

JWE（JSON Web Encryption） 是对 JWT **加密**的标准，用来保证数据**机密性**。**JWE** 是一种 **加密的 JSON Web Token**，用于安全地传输敏感数据。与普通 JWT（通常只签名，不加密）不同，JWE **加密了 payload**，确保数据在传输中机密性不被泄露。

JWE 通常有 **5 个部分**，用点 `.` 分隔：

```JWT
<Protected Header>.<Encrypted Key>.<Initialization Vector>.<Ciphertext>.<Authentication Tag>
```

#### 结构

- **Protected Header**（保护头）

  描述加密算法、密钥管理方式等信息。

  ```json
  {
    "alg": "RSA-OAEP",
    "enc": "A256GCM"
  }
  ```

- **Encrypted Key**（加密密钥）

  用接收方公钥加密的对称密钥（用于加密 payload）。

- **Initialization Vector (IV)**

  用于分组加密算法，保证加密结果随机化。

- **Ciphertext**（密文）

  加密后的实际 payload 数据。

- **Authentication Tag**

  验证密文未被篡改（完整性校验）。



### JWK

JWK (JSON Web Key) 是一种 JSON 格式的**密钥表示标准**，用于描述公钥、私钥或对称密钥。

| 字段     | 说明                                   |
| -------- | -------------------------------------- |
| `kty`    | 密钥类型：RSA、EC、oct（对称）等       |
| `use`    | 密钥用途：`sig`（签名）、`enc`（加密） |
| `alg`    | 预期算法，如 `RS256`、`A256GCM`        |
| `kid`    | 密钥 ID，用于快速查找密钥              |
| `n`、`e` | RSA 公钥参数                           |
| `d`      | RSA 私钥参数（如果是私钥）             |

```json
{
  "kty": "RSA",          // 密钥类型（RSA, EC, oct）
  "kid": "12345",        // 密钥 ID，用于标识
  "use": "enc",          // 用途：sig（签名）或 enc（加密）
  "alg": "RS256",        // 使用算法
  "n": "base64url...",   // 模数
  "e": "AQAB"            // 指数
}
```

