# 线上生产事故

## 多线程多事务导致死等待

类似两阶段提交的方案就会产生问题，1.主线程认为可以提交的时候，子线程部分挂了。2.如果线程数设置不合理，那么可能导致5个线程 4个线程执行完了阻塞了，还有一个线程在线程池的等待队列中，而4个线程又不会释放。

多线程多个事务之间的死锁

问题：线程A 使用id in 语句来更新多个id的数据，但是由于id的不连续性，该更新sql锁住整个表，执行完sql后该线程睡眠 等待唤醒

线程B 插入语句 因为和线程A不同的事务，所以会等待线程A的表锁释放才能进行插入数据操作，而此刻线程A处于睡眠等待，造成死锁。

优化：

1. 多线程使用同一个事务  遭遇慢sql可能还是会卡 不太推荐

2. 批量插入使用 insert into dbo.xxx values () ()
3. 可以全部不采用事务，将多个sql的更新结果记录日志，记录到单独的日志文件中，因为出错是极少的情况，一旦出错可以利用日志进行数据补偿来继续走下去
4. 拆分成多个事务，将速度快的事务先执行，速度慢的事务采用日志记录+单独事务执行的方式，出错可补救
5. 定时任务分片，将数据切片分发给多个机器，每个机器上操作一个分片的数据，只更新单个学校的数据整体，出错修复单个学校以及后续学校所有要操作的数据即可



## 多线程查询

多线程查询的性能虽然可以改善单个请求的时长，但是整体机器的资源是有限的，在整体的性能上并不能提升，相反还会降低机器的一定并发性能，多个线程的查询由于多个sql查询的请求，也会增大数据库节点的请求处理压力，且在线程池内，如果在执行的任务睡眠等待，而还有的任务处于任务等待队列中，那么会造成线程池的死等待。







## 其他知识

**sqlserver不支持使用insert批量插入返回主键id，mysql支持**

SELECT SCOPE_IDENTITY() AS NewID;

